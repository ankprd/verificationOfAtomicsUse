In this project we investigated potential limitations of the token-based reasoning tool devised in \cite{pascal}, based on the EFC permission structure defined in \cite{gaurav}, using FSL++ logic. At the beginning of this project, we expected to find limitations due to using only the EFC permission structure for ghost states, or to the simplifications further introduced by token-based reasoning. However, those new limitations were merely in ease of use of the system: those new tools are slightly diverging from our intuition of them, but we did not find any case where they actually restricted what could be proven. Surprisingly, the hard limits we encountered were those of FSL++. We showed that neither the glibc reader writer lock \cite{glibcRW} nor the Folly one producer one consumer queue \cite{queue} could be proven using this logic. Hence, while the infrastructure developed in \cite{gaurav} and \cite{pascal} has proven efficient so far in harnessing the potential of FSL++ for automated reasoning, it seems that FSL++ is limited in some fundamental ways, especially for synchronization mechanisms using loads and stores, and not only read modify writes.

Finally, we provided the first, to the best of our knowledge, proof of the Folly Serial Executor \cite{serialExec}. This proof demonstrates the effectiveness of FSL++ to prove correct intertwined independent synchronization mechanisms.

\section{Future work}

As developed above, the main limits we encountered were those of FSL++. This open at least three directions of work: trying to extend FSL++ to overcome those limits, or finding a new, more expressive, logic to build an infrastructure on. The first direction seems difficult, as the extensions would require some heavy changes to the logic, endangering its soundness proof. The second direction would require developing new abstractions and tools, and a more expressive logic would probably prove difficult to automate, at least partially. Finally, a third way would be to keep FSL++, and the infrastructure built in \cite{gaurav} and \cite{pascal}, for what they seem extremely efficient at: proving correct synchronization mechanisms that use only read modify writes, and exploring new examples that fit this category.

\section{Acknowledgments}
I would like to thank my supervisors Gaurav Parthasarathy and Alexander J. Summers for their guidance throughout this project. I would I also like to thank Prof. Peter MÃ¼ller for the opportunity to work on such an interesting topic.
