In this project I investigated potential limitations of the token-based reasoning tool devised in \cite{pascal}, based on the EFC permission structure defined in \cite{gaurav}, using FSL++ logic. At the beginning of this project, we expected to find limitations due to using only the EFC permission structure for ghost states, or to the simplifications further introduced by token-based reasoning. However, those new limitations were merely in ease of use of the system: those new tools are slightly diverging from our intuition of them, but we did not fing any case where they actually restricted what could be proven. Surprisingly, the hard limits we encountered were those of FSL++. We showed that neither glibc reader writer lock \cite{glibcRW} nor the Folly one producer one consumer queue \cite{queue} could be proven using this logic. Hence, while the infrastructure developped in \cite{gaurav} and \cite{pascal} has proven efficient so far in harnessing the potential of FSL++ for automated reasoning, it seems that FSL++ is limited in some fundamental ways, especially for synchronization mechanisms using loads and stores, and not only read-modify-writes.

Finally, I provided the first, to the best of my knowledge, proof of the Folly Serial Executor. This proof demonstrates the effectiveness of FSL++, and more generally separation logic, to prove correct intertwinned independant synchronization mechanisms.

\section{Future work}

As developped above, the main limits we encountered were those of FSL++. This open at least two directions of work: trying to extend FSL++ to overcome those limits, or fiding a new, more expressive, logic to build an infrastructure on. The first direction seems difficult, as the extensions would require some heavy changes to the logic, endangering its soundness proof. The second direction would require developping new abstraction and tools, and a more expressive logic would probably prove difficult to automate, at least partially. Finally, a third way would be to keep FSL++, and the infrastructure built in \cite{gaurav} and \cite{pascal}, for what they seem extremely efficient at: proving correct synchronization mechanisms using only read-modify-writes, and exploring new examples that fit this category,
