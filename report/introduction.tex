When reasoning about concurrent programs, the most intuitive setting is sequential consistency \cite{LamportSC}, where we consider the program to behave as if each of the threads' executions were simply interleaved. However, due to the many optimizations performed by modern compilers and hardware, such a model is too simplistic to accurately represent the actual executions of the program. We can hence only assume a weak memory model, which allows many more possible executions of the accesses to shared memory locations. However, these new possibilities of execution make reasoning about programs more difficult, and at times counterintuitive. Writing correct programs is hence extremely challenging in such a setting.

FSL++ \cite{fsl} is a program logic developed to reason about concurrent programs in C11, which are governed by the weak memory model defined in the C11 standard. This program logic allows for compositional proofs, through preconditions and postconditions for functions for instance. However, such proofs originally had to be encoded using the Coq interactive theorem prover, thus requiring a lot of ad hoc work for each new program considered.

%While these logics have successfully been used to prove some programs taken from real-world libraries, for instance in \cite{rcu}, these proofs still require a lot of ad-hoc work for each new program considered, as each proof has to be encoded in the Coq interactive theorem prover.

To try to alleviate this proof burden, part of this program logic has been encoded into Viper \cite{viper} by Summers and M\"uller \cite{rslViper}. However it did not provide any encoding for the notion of custom \emph{ghost state}, an important feature used to model information that cannot be deduced solely from the program state. This \emph{ghost state} is defined quite generally in FSL++, and needs to be specialized for each example, which makes their encoding and their use quite challenging. Parthasarathy et al. \cite{gaurav} provided such a specialization, the EFC permission structure, and showed that it was sufficient to prove the correctness of a variety of example programs. Building on this work, Wiesmann et al. \cite{pascal} was then able to define a specification syntax, token based reasoning, and its encoding in Viper. This syntax abstracts some details of the EFC ghost state and FSL++, such as rational permission amounts, limiting the complexity of this logic.
%, that allowed easier use of this specialization, without having to deal with lower level details. 
Wiesmann et al. \cite{pascal} also implemented a C++ front end for Viper using this specialization to provide more automation for proofs.  

This project explores this new infrastructure and tries to analyze some of its limitations, not only in terms of what it allows us to do, but also in how easily it allows us to do it. We were first able to identify a slight mismatch between the intuition of the EFC permission structure and token based reasoning. Furthermore, we found and studied three new real-world examples. The first two allowed us to identify strong limitations of FSL++ that forbid proving many kind of examples. We finally provide a proof of the last example, that uses two atomic locations, using the EFC permission structure. 
